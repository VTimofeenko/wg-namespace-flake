#+TITLE: Wireguard namespace flake
#+AUTHOR: Vladimir Timofeenko
#+EMAIL: id@vtimofeenko.com
#+DATE: <2022-11-09 Wed>
#+TAGS[]: fix(b) feat(f) doc(d) chore(c) to_think(t)

For a while I have been playing with the idea of running certain simple services in Linux namespaces to achieve network isolation from the "host" system on a desktop Linux. This project, written in literate programming style, is an Nix-based implementation of a configurable network namespace that uses Wireguard.

# more

The page is structured to match the implementation of the project. If you want to just use it -- jump straight to [[*Usage example][Usage example]] section.

* Flake
:PROPERTIES:
:header-args:nix: :tangle flake.nix :padline no
:END:

The flake will not have any specific inputs beyond ~nixpkgs~.

#+begin_src nix
{
  description = "A flake that implements Wireguard adapter that gets moved into a VPN namespace";
  outputs = { self, nixpkgs }:
#+end_src

The whole functionality of this flake will be expressed in a single module.

As of [[https://nixos.org/manual/nix/stable/release-notes/rl-2.8.html][Nix 2.8]] , ~nixosModules.default~ replaces ~nixosModule~:

#+begin_src  nix
    {
      nixosModules.default = import ./modules;
    };
}
#+end_src

* Module
:PROPERTIES:
:header-args:nix: :tangle modules/default.nix :padline no
:END:

By definition, Nix modules are functions that return attribute sets. This module will take as parameters:

- pkgs :: reference to current version of nixpkgs repository
- lib :: a collection of helper functions
- config :: reference to the system configuration
#+begin_src nix
{ pkgs, lib, config, ... }:
#+end_src

The latter parameter will be used to retrieve the service's configuration if it's defined:
#+begin_src nix
let
  cfg = config.services.wireguard-namespace;
in
{
#+end_src


This module will have two keys in the attrset:

- options :: where user-configurable options are exposed
- config :: where the configuration is implemented

** Options

This module will be passing a lot of options directly to ~nixpkgs~' default wireguard module. The order of the options does not matter, but I will be listing the module-specific options first, and the options taken from wireguard module at the end.

#+begin_src nix
  options.services.wireguard-namespace = with lib; {
    namespace_name = mkOption {
      type = types.str;
      description = "The name of the VPN network namespace";
      default = "vpn";
    };
    dns_server = mkOption {
      type = types.str;
      description = "IP address of the DNS server to be used in the network namespace";
    };
    extraFirewallRules = mkOption {
      type = types.str;
      default = "";
    };
    # Default options follow
    ips = mkOption {
        example = [ "192.168.2.1/24" ];
        default = [];
        type = with types; listOf str;
        description = "The IP addresses of the interface.";
    };
    privateKeyFile = mkOption {
      example = "/private/wireguard_key";
      type = with types; nullOr str;
      description = ''
          Private key file as generated by <command>wg genkey</command>.
        '';
    };
    peers = let
      peerOpts = {

        options = {

          publicKey = mkOption {
            example = "xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=";
            type = types.str;
            description = "The base64 public key of the peer.";
          };

          presharedKey = mkOption {
            default = null;
            example = "rVXs/Ni9tu3oDBLS4hOyAUAa1qTWVA3loR8eL20os3I=";
            type = with types; nullOr str;
            description = ''
          Base64 preshared key generated by <command>wg genpsk</command>.
          Optional, and may be omitted. This option adds an additional layer of
          symmetric-key cryptography to be mixed into the already existing
          public-key cryptography, for post-quantum resistance.
          Warning: Consider using presharedKeyFile instead if you do not
          want to store the key in the world-readable Nix store.
        '';
          };

          presharedKeyFile = mkOption {
            default = null;
            example = "/private/wireguard_psk";
            type = with types; nullOr str;
            description = ''
          File pointing to preshared key as generated by <command>wg genpsk</command>.
          Optional, and may be omitted. This option adds an additional layer of
          symmetric-key cryptography to be mixed into the already existing
          public-key cryptography, for post-quantum resistance.
        '';
          };

          allowedIPs = mkOption {
            example = [ "10.192.122.3/32" "10.192.124.1/24" ];
            type = with types; listOf str;
            description = ''List of IP (v4 or v6) addresses with CIDR masks from
        which this peer is allowed to send incoming traffic and to which
        outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may
        be specified for matching all IPv4 addresses, and ::/0 may be specified
        for matching all IPv6 addresses.'';
          };

          endpoint = mkOption {
            default = null;
            example = "demo.wireguard.io:12913";
            type = with types; nullOr str;
            description = ''Endpoint IP or hostname of the peer, followed by a colon,
        and then a port number of the peer.
        Warning for endpoints with changing IPs:
        The WireGuard kernel side cannot perform DNS resolution.
        Thus DNS resolution is done once by the <literal>wg</literal> userspace
        utility, when setting up WireGuard. Consequently, if the IP address
        behind the name changes, WireGuard will not notice.
        This is especially common for dynamic-DNS setups, but also applies to
        any other DNS-based setup.
        If you do not use IP endpoints, you likely want to set
        <option>networking.wireguard.dynamicEndpointRefreshSeconds</option>
        to refresh the IPs periodically.
        '';
          };

          dynamicEndpointRefreshSeconds = mkOption {
            default = 0;
            example = 5;
            type = with types; int;
            description = ''
          Periodically re-execute the <literal>wg</literal> utility every
          this many seconds in order to let WireGuard notice DNS / hostname
          changes.
          Setting this to <literal>0</literal> disables periodic reexecution.
        '';
          };

          persistentKeepalive = mkOption {
            default = null;
            type = with types; nullOr int;
            example = 25;
            description = ''This is optional and is by default off, because most
        users will not need it. It represents, in seconds, between 1 and 65535
        inclusive, how often to send an authenticated empty packet to the peer,
        for the purpose of keeping a stateful firewall or NAT mapping valid
        persistently. For example, if the interface very rarely sends traffic,
        but it might at anytime receive traffic from a peer, and it is behind
        NAT, the interface might benefit from having a persistent keepalive
        interval of 25 seconds; however, most users will not need this.'';
          };

        };

      };
    in
      mkOption {
        default = [];
        description = "Peers linked to the interface.";
        type = with types; listOf (submodule peerOpts);
      };
  };
#+end_src

** Config
Now, for the implementation, that is wrapped in ~config~ attribute:

#+begin_src nix
  config = {
#+end_src
*** Preventing DNS leaks
Linux network namespaces allow bind-mounting files in ~/etc/netns/<NAMESPACE_NAME>~ over files in ~/etc~. Processes within the namespace will only see the contents of the bind-mounted files.

This approach does have drawbacks, as bind-mounts disappear if the original file's inode changes. See [[https://unix.stackexchange.com/questions/418304/why-do-linux-bind-mounts-disappear-if-the-mount-points-inode-changes][this SO thread]].

#+begin_src nix
    environment.etc = {
      "netns/${cfg.namespace_name}/resolv.conf".text = ''nameserver ${cfg.dns_server}'';
      # This setting forces the use of resolv.conf instead of dbus interface provided by systemd-resolved
      "netns/${cfg.namespace_name}/nsswitch.conf".text = ''
        passwd:    files systemd
        group:     files systemd
        shadow:    files

        hosts:     dns
        networks:  files

        ethers:    files
        services:  files
        protocols: files
        rpc:       files
      '';
    };
#+end_src

But it's better than nothing. Alternative approach to consider is using the ~nftables~ to  [[*add DNS leak prevention to nftables][reroute all outgoing traffic on port 53 to the desired DNS server]].


**** TODO add DNS leak prevention to nftables :feat:
*** Firewall
Speaking of, the namespace also has its own firewall. On a generic client machine typically no ports should be listening in the namespace, so the firewall should just disallow all forwarding and input:

#+begin_src nftables :tangle modules/namespace_default_fw.nft
# Sourced from archwiki on 2022-03-20
# https://wiki.archlinux.org/title/Nftables#Workstation
# Adapted to not having any LAN or IPv6

flush ruleset

table inet my_table {
    chain my_input {
        type filter hook input priority filter; policy drop;
        iif lo accept comment "Accept any localhost traffic"

        ct state invalid drop comment "Drop invalid connections"
        ct state established,related accept comment "Accept traffic originated from us"

        meta l4proto icmp accept comment "Accept ICMP"
        ip protocol igmp accept comment "Accept IGMP"

        counter comment "Count any other traffic"
    }

    chain my_forward {
        type filter hook forward priority filter; policy drop;
        # Drop everything forwarded to us. We do not forward. That is routers job.
    }

    chain my_output {
        type filter hook output priority filter; policy accept;
        # Accept every outbound connection
    }
}
#+end_src

*** Putting it all together
This file will be placed inside the ~etc/netns/vpn~ and the namespace will be configured to use that set of rules. If ~cfg.extraFirewallRules~ value is specified - it will be appended to the default rules.

#+begin_src nix
    environment.etc."nftables.d/${cfg.namespace_name}-namespace/${cfg.namespace_name}.nft".text = ''
      ${builtins.readFile ./namespace_default_fw.nft}

      ${cfg.extraFirewallRules}

    '';
#+end_src

The interface itself will be configured through the standard ~networking.wireguard.interfaces~ module, but it will perform some additional namespace configuration.

#+begin_src nix
    networking.wireguard.interfaces."${cfg.namespace_name}" = {
      ips = cfg.ips;
      privateKeyFile = cfg.privateKeyFile;
      interfaceNamespace = cfg.namespace_name;
      peers = cfg.peers;

#+end_src

The module will configure the network adapter to:
1. Create a namespace before starting
2. Set up the firewall within the namespace
3. After destroying the adapter (e.g. service is stopped) - namespace will be removed

#+begin_src nix
      preSetup = [
        ''${pkgs.iproute2}/bin/ip netns add ${cfg.namespace_name}''
        ''${pkgs.iproute2}/bin/ip netns exec ${cfg.namespace_name} ${pkgs.nftables}/bin/nft --file /etc/nftables.d/${cfg.namespace_name}-namespace/${cfg.namespace_name}.nft''

      ];
      postShutdown = [ ''${pkgs.iproute2}/bin/ip netns del ${cfg.namespace_name}'' ];
    };
  };
}
#+end_src


* Usage example

To use this project:

1. Add it as an input for the system configuration flake, for example:

    #+begin_src nix :tangle no
    inputs = {
      ...
      wg-namespace-flake = {
        url = "github:VTimofeenko/wg-namespace-flake";
        inputs.nixpkgs.follows = "nixpkgs";
      };
      ...
    }
    #+end_src
2. Add the ~inputs.wg-namespace-flake.nixosModules.default~ to the list of imported modules
3. Configure the service by importing a module like this (assumes using [[https://github.com/ryantm/agenix][agenix]] for secret management):

    #+begin_src nix :tangle no
    { config, ... }:
    {
      services.wireguard-namespace = {
        dns_server = "<SOME_DNS_SERVER>";
        ips = [ "<INTERFACE-SPECIFIC-IP-ADDRESS>" ];
        privateKeyFile = config.age.secrets.my_vpn_key.path;
        peers = [
          {
            publicKey = "<PUBLIC_KEY>";
            allowedIPs = [ "0.0.0.0/0" ];  # To route all traffic through this peer
            endpoint = "<ENDPOINT>";
          }
        ];
      };
    }
    #+end_src

4. Run ~nixos-rebuild switch~

As a result, the commands running the namespace with the VPN will route the traffic through the peer:

#+begin_src shell
# outside the namespace
❯ curl ifconfig.co
<local IP>
# inside the namespace
❯ firejail --noprofile --blacklist=/var/run/nscd/socket --netns=vpn --dns=10.2.1.2 curl ifconfig.co 2>/dev/null
<Outgoing IP of the peer>
#+end_src

;; Local Variables:
;; eval: (load-file (expand-file-name "nftables-mode.el" (file-name-directory (buffer-file-name))))
;; eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t)
;; eval: (defun nixpkgs-fmt-on-tangle() (when (string-suffix-p ".nix" (buffer-file-name)) (shell-command (format "nixpkgs-fmt %s" (buffer-file-name)))))
;; eval: (add-hook 'org-babel-post-tangle-hook 'nixpkgs-fmt-on-tangle)
;; End:
